{"remainingRequest":"D:\\Angular-Test\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\Angular-Test\\node_modules\\rxjs\\_esm5\\observable\\BoundCallbackObservable.js","dependencies":[{"path":"D:\\Angular-Test\\node_modules\\rxjs\\_esm5\\observable\\BoundCallbackObservable.js","mtime":1517715510484},{"path":"D:\\Angular-Test\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\Angular-Test\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { Observable } from '../Observable';\r\nimport { tryCatch } from '../util/tryCatch';\r\nimport { errorObject } from '../util/errorObject';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport var BoundCallbackObservable = /*@__PURE__*/ (function (_super) {\r\n    __extends(BoundCallbackObservable, _super);\r\n    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\r\n        _super.call(this);\r\n        this.callbackFunc = callbackFunc;\r\n        this.selector = selector;\r\n        this.args = args;\r\n        this.context = context;\r\n        this.scheduler = scheduler;\r\n    }\r\n    /* tslint:enable:max-line-length */\r\n    /**\r\n     * Converts a callback API to a function that returns an Observable.\r\n     *\r\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\r\n     * it will return a function `g` that when called as `g(x)` will output an\r\n     * Observable.</span>\r\n     *\r\n     * `bindCallback` is not an operator because its input and output are not\r\n     * Observables. The input is a function `func` with some parameters, the\r\n     * last parameter must be a callback function that `func` calls when it is\r\n     * done.\r\n     *\r\n     * The output of `bindCallback` is a function that takes the same parameters\r\n     * as `func`, except the last one (the callback). When the output function\r\n     * is called with arguments it will return an Observable. If function `func`\r\n     * calls its callback with one argument the Observable will emit that value.\r\n     * If on the other hand the callback is called with multiple values the resulting\r\n     * Observable will emit an array with said values as arguments.\r\n     *\r\n     * It is very important to remember that input function `func` is not called\r\n     * when the output function is, but rather when the Observable returned by the output\r\n     * function is subscribed. This means if `func` makes an AJAX request, that request\r\n     * will be made every time someone subscribes to the resulting Observable, but not before.\r\n     *\r\n     * Optionally, a selector function can be passed to `bindObservable`. The selector function\r\n     * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\r\n     * Even though by default multiple arguments passed to callback appear in the stream as an array\r\n     * the selector function will be called with arguments directly, just as the callback would.\r\n     * This means you can imagine the default selector (when one is not provided explicitly)\r\n     * as a function that aggregates all its arguments into an array, or simply returns first argument\r\n     * if there is only one.\r\n     *\r\n     * The last optional parameter - {@link Scheduler} - can be used to control when the call\r\n     * to `func` happens after someone subscribes to Observable, as well as when results\r\n     * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\r\n     * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\r\n     * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\r\n     * and call `subscribe` on the output Observable all function calls that are currently executing\r\n     * will end before `func` is invoked.\r\n     *\r\n     * By default results passed to the callback are emitted immediately after `func` invokes the callback.\r\n     * In particular, if the callback is called synchronously the subscription of the resulting Observable\r\n     * will call the `next` function synchronously as well.  If you want to defer that call,\r\n     * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\r\n     * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\r\n     *\r\n     * Note that the Observable created by the output function will always emit a single value\r\n     * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\r\n     * calls will not appear in the stream. If you need to listen for multiple calls,\r\n     *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\r\n     *\r\n     * If `func` depends on some context (`this` property) and is not already bound the context of `func`\r\n     * will be the context that the output function has at call time. In particular, if `func`\r\n     * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\r\n     * it is recommended that the context of the output function is set to that object as well.\r\n     *\r\n     * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\r\n     * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\r\n     * provides convenient error handling and probably is a better choice.\r\n     * `bindCallback` will treat such functions the same as any other and error parameters\r\n     * (whether passed or not) will always be interpreted as regular callback argument.\r\n     *\r\n     *\r\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\r\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\r\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\r\n     * var result = getJSONAsObservable('/my/url');\r\n     * result.subscribe(x => console.log(x), e => console.error(e));\r\n     *\r\n     *\r\n     * @example <caption>Receive an array of arguments passed to a callback</caption>\r\n     * someFunction((a, b, c) => {\r\n     *   console.log(a); // 5\r\n     *   console.log(b); // 'some string'\r\n     *   console.log(c); // {someProperty: 'someValue'}\r\n     * });\r\n     *\r\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\r\n     * boundSomeFunction().subscribe(values => {\r\n     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\r\n     * });\r\n     *\r\n     *\r\n     * @example <caption>Use bindCallback with a selector function</caption>\r\n     * someFunction((a, b, c) => {\r\n     *   console.log(a); // 'a'\r\n     *   console.log(b); // 'b'\r\n     *   console.log(c); // 'c'\r\n     * });\r\n     *\r\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\r\n     * boundSomeFunction().subscribe(value => {\r\n     *   console.log(value) // 'abc'\r\n     * });\r\n     *\r\n     *\r\n     * @example <caption>Compare behaviour with and without async Scheduler</caption>\r\n     * function iCallMyCallbackSynchronously(cb) {\r\n     *   cb();\r\n     * }\r\n     *\r\n     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\r\n     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\r\n     *\r\n     * boundSyncFn().subscribe(() => console.log('I was sync!'));\r\n     * boundAsyncFn().subscribe(() => console.log('I was async!'));\r\n     * console.log('This happened...');\r\n     *\r\n     * // Logs:\r\n     * // I was sync!\r\n     * // This happened...\r\n     * // I was async!\r\n     *\r\n     *\r\n     * @example <caption>Use bindCallback on an object method</caption>\r\n     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\r\n     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\r\n     * .subscribe(subscriber);\r\n     *\r\n     *\r\n     * @see {@link bindNodeCallback}\r\n     * @see {@link from}\r\n     * @see {@link fromPromise}\r\n     *\r\n     * @param {function} func A function with a callback as the last parameter.\r\n     * @param {function} [selector] A function which takes the arguments from the\r\n     * callback and maps them to a value that is emitted on the output Observable.\r\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\r\n     * callbacks.\r\n     * @return {function(...params: *): Observable} A function which returns the\r\n     * Observable that delivers the same values the callback would deliver.\r\n     * @static true\r\n     * @name bindCallback\r\n     * @owner Observable\r\n     */\r\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\r\n        if (selector === void 0) {\r\n            selector = undefined;\r\n        }\r\n        return function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i - 0] = arguments[_i];\r\n            }\r\n            return new BoundCallbackObservable(func, selector, args, this, scheduler);\r\n        };\r\n    };\r\n    BoundCallbackObservable.prototype._subscribe = function (subscriber) {\r\n        var callbackFunc = this.callbackFunc;\r\n        var args = this.args;\r\n        var scheduler = this.scheduler;\r\n        var subject = this.subject;\r\n        if (!scheduler) {\r\n            if (!subject) {\r\n                subject = this.subject = new AsyncSubject();\r\n                var handler = function handlerFn() {\r\n                    var innerArgs = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        innerArgs[_i - 0] = arguments[_i];\r\n                    }\r\n                    var source = handlerFn.source;\r\n                    var selector = source.selector, subject = source.subject;\r\n                    if (selector) {\r\n                        var result_1 = tryCatch(selector).apply(this, innerArgs);\r\n                        if (result_1 === errorObject) {\r\n                            subject.error(errorObject.e);\r\n                        }\r\n                        else {\r\n                            subject.next(result_1);\r\n                            subject.complete();\r\n                        }\r\n                    }\r\n                    else {\r\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\r\n                        subject.complete();\r\n                    }\r\n                };\r\n                // use named function instance to avoid closure.\r\n                handler.source = this;\r\n                var result = tryCatch(callbackFunc).apply(this.context, args.concat(handler));\r\n                if (result === errorObject) {\r\n                    subject.error(errorObject.e);\r\n                }\r\n            }\r\n            return subject.subscribe(subscriber);\r\n        }\r\n        else {\r\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\r\n        }\r\n    };\r\n    BoundCallbackObservable.dispatch = function (state) {\r\n        var self = this;\r\n        var source = state.source, subscriber = state.subscriber, context = state.context;\r\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\r\n        var subject = source.subject;\r\n        if (!subject) {\r\n            subject = source.subject = new AsyncSubject();\r\n            var handler = function handlerFn() {\r\n                var innerArgs = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    innerArgs[_i - 0] = arguments[_i];\r\n                }\r\n                var source = handlerFn.source;\r\n                var selector = source.selector, subject = source.subject;\r\n                if (selector) {\r\n                    var result_2 = tryCatch(selector).apply(this, innerArgs);\r\n                    if (result_2 === errorObject) {\r\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject.e, subject: subject }));\r\n                    }\r\n                    else {\r\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\r\n                    }\r\n                }\r\n                else {\r\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\r\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\r\n                }\r\n            };\r\n            // use named function to pass values in without closure\r\n            handler.source = source;\r\n            var result = tryCatch(callbackFunc).apply(context, args.concat(handler));\r\n            if (result === errorObject) {\r\n                subject.error(errorObject.e);\r\n            }\r\n        }\r\n        self.add(subject.subscribe(subscriber));\r\n    };\r\n    return BoundCallbackObservable;\r\n}(Observable));\r\nfunction dispatchNext(arg) {\r\n    var value = arg.value, subject = arg.subject;\r\n    subject.next(value);\r\n    subject.complete();\r\n}\r\nfunction dispatchError(arg) {\r\n    var err = arg.err, subject = arg.subject;\r\n    subject.error(err);\r\n}\r\n//# sourceMappingURL=BoundCallbackObservable.js.map \r\n",null]}